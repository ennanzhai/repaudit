// simple parser
#include <iostream>
#include <vector>
#include <fstream>
#include <string>
#include <sstream>
#include <regex>

#include "../include/parser.hpp"

int main(int argc, char * argv[]){
	if(argc != 3){
	  cout<<"usage: parser <input file> <output file>"<<endl;
	  return -1;
	}
	string filename(argv[1]);
	Parser parser(filename);
	if(!parser.fail()){
		parser.output(argv[2]);
	}
}

Parser::Parser(string filename){
  ifstream input(filename);
  string line;
  init();
  if(input.is_open()){
  	  string lvariable;
  	  string functionName = "InputFile";
  	  string parameter = "\"" + filename + "\"";
  	  vector<string> parameters = {parameter};
  	  genStatement(lvariable, functionName, parameters);
	  while(getline(input, line)){
		lineNum++;
		trim(line);
		if(line.empty())
			continue;
		processLine(line);
	  }
  }
  else cout<<"Unable to open file: " <<filename.c_str()<<endl;
  input.close();
}


void Parser::init(){
  isError = false;
  lineNum = 0;
  // init function map
  functionMap["InputFile"] = "inputFile";
  functionMap["FailureGraph"] = "faultGraph";
  functionMap["server"] = "server";
  functionMap["switch"] = "_switch";
  functionMap["edge"] = "edge";
  functionMap["AddEdge"] = "addEdge";
  functionMap["AddNode"] = "addNode";
  functionMap["RankRCG"] = "rankRCG";
  functionMap["FailProb"] = "failProb";
  functionMap["RankNode"] = "rankNode";
  functionMap["RecRep"] = "recRep";
  functionMap["print"] = "print"; // TODO write overloading function print
  functionMap["list"] = "genVector"; // reserved.
  functionMap["Goal"] = "goal";
  // init header 
  header.push_back("// Auto generated file");
  header.push_back("// Generated by Left-right parser");
  header.push_back("#include \"../include/primitive.hpp\"");
  header.push_back("using namespace std;");
  header.push_back("");
  header.push_back("int main(int argc, char const *argv[])");
  header.push_back("{");

  footer.push_back("\treturn 0;");
  footer.push_back("}");
}

// genenrate output file
void Parser::output(string filename){
	ofstream outfile;
	outfile.open(filename);
	for(auto it = header.begin(); it != header.end(); it++){
		outfile << *it << endl;
	}
	for(auto it = statements.begin(); it != statements.end(); it++){
		outfile << "\t" << *it << endl;
	}

	for(auto it = footer.begin(); it != footer.end(); it++){
		outfile << *it << endl;
	}
	outfile.close();
}

// trim comments and heading, trailing spaces
void Parser::trim(string& line){
	string::size_type pos = line.find("//");
	line = line.substr(0, pos); // delete comments
	trimWhitespaces(line);
}

void Parser::trimWhitespaces(string& line){
	size_t start, end;
	if(line.empty()) return ;
	// trim heading 
	for(start = 0; start < line.size(); start++){
		if(line[start] != ' ' && line[start] != '\t'){
			break;
		}
	}
	// all white spaces
	if(start == line.size()){
		line.clear();
		return ;
	}
	for(end = line.size() - 1; end >= start; end--){
		if(line[end] != ' ' && line[end] != '\t'){
			break;
		}
	}
	line = line.substr(start, end - start + 1);
}
void Parser::processLine(string line){
	// line is trimmed. No heading spaces and no trailing comments. Non empty.
	string lvariable, functionName;
	string left, right;
	vector<string> parameters;
	int pos;
	pos = line.find('=');
	// = exist in statement
	if(pos != -1)
		left = line.substr(0, pos);
	right = line.substr(pos + 1, -1);
	// extract lvariable in left part
	trimWhitespaces(left);
	if(!left.empty()){
		extractVariable(left, lvariable);
	}

	// extract function name or '[]' in right part
	trimWhitespaces(right);
	if(!right.empty()){
		extractFunction(right, functionName, parameters);
	}else{
		printe("incomplete statement");
	}

	// gen statement
	if(!fail())
		genStatement(lvariable, functionName, parameters);
}
void Parser::printe(string s){
	cout << "Line "<< lineNum << ": "<< s <<endl; 
	isError = true;
}

void Parser::genStatement(string &lvariable, string& functionName, vector<string>& parameters){
	string statement;
	ostringstream ss;
	// left value exists -*** edit by Xi
	if(!lvariable.empty()){
		if(variableMap.find(lvariable) != variableMap.end()){
			ss << lvariable << " = ";
		}else{
			ss << "auto " << lvariable << " = ";
			variableMap.insert(lvariable);
		}
	}
	//***

	// check if function name is known or not
	if(functionMap.find(functionName) == functionMap.end()){
		ostringstream msg;	
		msg << "unknown function name: " << functionName; 
		printe(msg.str());
		return ;
	}
	ss << functionMap[functionName] << "(";
	
	if(!lvariable.empty() && (functionName == "server" || functionName == "switch" || functionName == "FailureGraph")){
		ss << "\"" << lvariable << "\"" << ", ";
	} 
	// loop parameters
	auto it = parameters.begin();
	
	// insert first parameter
	if(it != parameters.end()){
		ss << *it ;
		it++;
	}
	while(it != parameters.end()){
	    ss << ", " << *it;
		it++;
	}

	// end of statement
	ss << ");";
	statements.push_back(ss.str());
	
}
void Parser::extractFunction(string line, string& functionName, vector<string>& parameters){
	trimWhitespaces(line);
	if(line.back() != ';'){
		printe("missing ';'");
	}
	
	if(line.find('[') != string::npos && line.find(']') != string::npos){
		// test if '[' and ']' exist
		int leftBracket = line.find('[');
		int rightBracket = line.find(']');
		if(leftBracket != 0){
			printe("syntax error, you mean '('?");
		}
		string parameterList = line.substr(leftBracket + 1, rightBracket - leftBracket - 1);
		extractParameter(parameterList, parameters);
		functionName = "list";
	}else if(line.find('(') != string::npos && line.find(')') != string::npos){
		// extract normal function
		int leftParentheses = line.find('(');
		int rightParentheses = line.find(')');
		functionName = line.substr(0, leftParentheses);
		if(functionName.empty()){
			printe("missing function name");
		}
		string parameterList = line.substr(leftParentheses + 1, rightParentheses - leftParentheses - 1);
		extractParameter(parameterList, parameters);
		if(parameters.size() == 0){
			printe("parameter format error");
		}
	}else{
		if(line.find('(') == string::npos){
			printe("missing '('");
		}else{
			printe("missing ')'");
		}
	}
}

// extract list [s1, s2] statements
void Parser::extractParameter(string s_parameters, vector<string>& parameters){
	regex pattern("[^, \t]+");
	sregex_iterator next(s_parameters.begin(), s_parameters.end(), pattern);
	sregex_iterator end;
	while(next != end){
		//cout << next ->str() << " ";
		parameters.push_back(next->str());
		next++;
	}
	//cout << endl;
}
void Parser::extractVariable(string left, string& variableName){
	regex patten("\\w+");
	sregex_iterator next(left.begin(), left.end(), patten);
	sregex_iterator end;
	int numToken = distance(next, end);
	//** edit by Xi
	if(numToken == 1){
		if(variableMap.find(next->str()) == variableMap.end()){
			printe("Format error, multiple variable name?");
		}else{
			variableName = next->str();
		} //**
	}else{
		if(numToken != 2){
			printe("Format error, multiple variable name?");
		}
		string label = next->str();
		if(label != "let"){
			printe("Format error, missing 'let'?");
		}
		next++;
		variableName = next->str();
	}
}
